#!/usr/bin/python
import sys, os
from optparse import OptionParser

from easy_extract import VERSION
from easy_extract.archives.xtm import XtmArchive
from easy_extract.archives.rar import RarArchive
from easy_extract.archives.seven_zip import SevenZipArchive
from easy_extract.archive_finder import ArchiveFinder

# Patch for disabling extractions
def _fake_extract(cls):
    print 'Extract : %s' % cls
    return True

#XtmArchive._extract = _fake_extract
#RarArchive._extract = _fake_extract
#SevenZipArchive._extract = _fake_extract

class EasyExtract(ArchiveFinder):
    """User interface for extracting archives"""

    def __init__(self, path, recursive=False,
                 force_extract=False, repair=True):
        self.force_extract = force_extract
        self.repair = repair
        self.archives_classes = [RarArchive, SevenZipArchive, XtmArchive,]
        self.excludes = []

        super(EasyExtract, self).__init__(path, recursive,
                                          self.archives_classes)

        if self.can_extract(self.force_extract):
            self.extract_archives(self.repair)
        else:
            print 'Nothing to do !'

    def get_path_archives(self, path, filenames, archive_classes):
        print 'Scanning %s...' % os.path.abspath(path)
        archives = super(EasyExtract, self).get_path_archives(
              path, filenames, archive_classes)
        return archives

    def can_extract(self, force):
        if self.archives:
            if force: return True
            for archive in self.archives:
                print archive

            extract = raw_input('Extract all ? [Y]es / No / Select : ')
            if not extract or 'y' in extract.lower():
                return True
            if 's' in extract.lower():
                for archive in self.archives:
                    extract = raw_input('Extract %s ? [Y]es / No : ' % archive)
                    if extract and not 'y' in extract.lower():
                        self.excludes.append(archive)
                return bool(self.archives)
        return False

    def extract_archives(self, repair):
        for archive in self.archives:
            if archive not in self.excludes:
                result = archive.extract(repair)

if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option('-d', '--directory', dest='directory',
                      help='Directory to where to find archives', default='.',
                      metavar='DIRECTORY')
    parser.add_option('-f', '--force', dest='force_extract', action='store_true',
                      help='Do not prompt confirmation message', default=False)
    parser.add_option('-n', '--not-repair', dest='repair', action='store_false',
                      help='Do not try to repair archives on errors', default=True)
    parser.add_option('-r', '--recursive', dest='recursive', action='store_true',
                      help='Find archives recursively', default=False)

    (options, args) = parser.parse_args()

    print '--** Easy Extract v%s **--' % VERSION
    EasyExtract(options.directory, options.recursive,
                options.force_extract, options.repair)
